###Section 4-4 リレーションシップとForeignkey
    #テーブルの連携
        例えば、簡単な掲示板で投稿するメッセージを管理するテーブルと利用者を管理するテーブルがあるとして、それぞれのメッセージには「誰が投稿したか」と
        いう情報を利用者テーブルから持ってきて使うことになる。つまり、メッセージのテーブルにある1つ1つのレコードには、「これを投稿した利用者のレコード」
        が関連付けられていなければいけない。（このテーブルのレコードには、こっちのテーブルのレコードを関連付けておかないといけない）
        これが「テーブルの連携」。Djangoでは、こうした関連付けを「リレーションシップ」と呼ぶ。
        
        リレーションシップは、本格Webアプリを作るようになると必ず必要。
        これは、実際に何度も自分で作って、体で覚える。
        
        #リレーションシップの種類
            例）メッセージテーブル     利用者テーブル
            2つのテーブルのレコードがどのような形で結びついているかによって大きく4つの種類に分けて考えることができる。
            
            ●1対1対応
                テーブルAのレコード1つに対して、テーブルBのレコード1つが対応する。
                例えば、住宅会社のデータベースに販売した住宅のテーブルと、顧客のテーブルがあるとして、ある住宅はそれを購入した顧客と1対1で結びついている。
                ２つのテーブルのレコードが1つずつ結びついているような関係が、1対1対応。
                
            ●1対多対応
                テーブルAのレコード1つに対して、テーブルBのレコード複数が対応する
                もっとも一般的にみられる関係。
                例えば、オークションサイトの顧客と出品データのテーブルをイメージして、ある顧客には落札したいくつもの商品データが関連付けられているはず。
                つまり、顧客テーブルのレコード1つに対して、出品テーブルの複数のレコードが関連付けられる形になる。これが1対多対応。
                
            ●多対1対応
                「1対多」対応は、逆から見れば、「多対1」の対応にもなっている。オークションサイトの例であいえば、複数の落札データに対し、
                1つの顧客が対応している形。
                
            ●多対多対応
                テーブルAの複数のレコードに対して、テーブルBの複数のレコードが対応している、というような関連付け。
                例えば、オンラインショップのデータベースをイメージして、オンラインショップではある商品をたくさんの顧客に販売します。
                つまり、ある顧客は複数の商品を購入しているし、ある商品は複数の顧客に販売している。こういうお互いに相手の複数レコードに
                関連付けられるようなものが多対多対応の関係。
    
    #リレーションシップの設定方法
        リレーションシップの設定はモデルから行う。モデルの中に、関連付ける相手のモデルに関する項目を用意することで、両者の関連がわかるようになる。
        
        #1対多 / 多対1の関連付け
            もっとも一般的で使うことが多い「1対多」「多対1」の関連付け
                ●主モデル(「1」側)
                    class A(models.Model):
                        項目
                ●従モデル(「多」側)
                    class B(models.Model):
                        項目 = models.ForeignKey(モデル名)
                        項目
            関連付けを考えるとき、「どちらが主で、どちらが従か」ということを頭に入れて考えるようにする。
            1対多対応では、「1 」側が主テーブル、「多」側が従テーブルとなる。
            1対多の「1」側には、特に何の仕掛けがない。「多」側のモデルにある。
            モデルにmodels.ForeignKeyという項目を用意しておく。
            「ForeignKey」というのは、外部キーのクラスで、外部キーというのは、このモデルに割り当てられているテーブル以外のテーブル用のキーという意味
            データベースのテーブルには、自動的に組み込まれるプライマリキーというものがあって、このプライマリキーは、すべてのレコードに割り当てらる、
            値の重複していないID番号のようなもの。
            データベースは、このプライマリキーを使って個々のレコードを識別している。
            外部キーは、このプライマリキーを保管するためのキー（テーブルに用意する項目）。つまり、あるテーブルのレコードに関連する別のテーブルの
            プライマリキーを、この外部キーに保管しておく。
            
            ######  テーブルの「主従」とは ######
                関連付けをするとき、「どっちがより重要か」。
                わかりやすく言えば、「絶対にないと困るのが主テーブル」
        
        #1対1の関連付け
            主テーブルには特に必要なものはなく、従テーブル側に関連付けのための項目を用意
                ●主モデル
                    class A(models.Model):
                        項目
                ●従モデル
                    class B(models.Model):
                        項目 = models.OneToOneField(モデル名)
                        項目
            従モデルに、models.OneToOneFieldというクラスの項目が用意されている。これが、1対1の関連付けに
        
        #多対多の関連付け
            多対多の関連付けも、基本的には同じような形。従テーブル側のモデルに、主テーブルのモデルを保管する項目を用意しておく。
                ●主モデル
                    class A(models.Model):
                        項目
                ●従モデル
                    class B(models.Model):
                        項目 = models.ManyToManyField(モデル名)
                        項目
            ここで、「ManyToManyField」が、そのためのクラス。これに主テーブルのモデルを引数に指定して項目として用意しておく。
        
        #1対1、多対多の「主」テーブルとは
            従テーブル側のモデルにリレーションシップのための項目を用意しておく。
            問題は、「どっちのテーブルが『主』なのか？」。
            1対多の場合、「1の側が主、多の側が従」で、1対1や多対多の場合、どっちが主なのかわかりにくい。
            わかりにくい場合は、「なくてもいいのはどっちか」を考える。「こっちは必ず用意される」「こっちはなくてもいい」という違いが分かれば、
            必ず用意するべき側が「主」、そうでない側は「従」となる。
    
    #メッセージ投稿のシステムを考える
        既に、Friendで利用者のテーブルは用意してある。あとは、投稿メッセージのテーブルを用意する
        1人の利用者は、いくつもメッセージを投稿することができるので、「1対多」の関係になる。投稿者が主テーブル、メッセージが従テーブルとなる。
 、     
        #メッセージテーブルを設計する
            タイトル：タイトルのテキスト
            コンテンツ：これが投稿するメッセージ
            投稿日時：投稿した日時
            
    #Messageモデル作成   →   アプリ名/models.pyに追記
        class Message(models.Model):
            friend = models.ForeignKey(Friend, on_delete=models.CASCADE)
            title = models.CharField(max_length=100)
            content = models.CharField(max_length=300)
            pub_date = models.DateTimeField(auto_now_add=True)
            
            def __str__(self):
                return '<Message:id=' + str(self.id) + ', ' + self.title + '(' + str(self.pub_date) + ')>'
                
            class Meta:
                ordering = ('pub_data',)
                
        friend：ForeignKeyの項目。これで、関連するFriendの情報を設定する。on_deleteは、削除する際の設定で、これはmodels.CASCADEを指定すると
                覚えてしまってOKです。
        title：タイトルのテキストを保管するためのもの。max_lengthで最大文字数を100にしている。
        content：コンテンツを保管するためのもの。これが、メッセージ本体、max_lengthで最大300文字に設定
        pub_date：投稿した日時を保管する。auto_now_addというのは、自動的に値を設定するためのもの。
        
       この他、__str__メソッドでテキスト表示を用意している。
       また、「Meta」というクラスはクラスの基本的な設定などを行う。ここｒ￥でorderingという値は並び順の情報を設定するもので、
       pub_date順に並べるように設定している。
       
   #マイグレーション実行
        作成したモデルをマイグレーションする。
        python manage.py makemigrations アプリ名    →   アプリ名/migrationsに0002_message.pyが作成されたのか確認
        確認出来たら、マイグレーションを実行  →   python manage.py migrate
    
    #admin.pyの修正    →   アプリ名/admin.pyに追記
        マイグレーションができたら管理ツールに登録。
        
        from django.contrib import admin
        from .models import Friend, Message
        
        admin.site.register(Friend)
        admin.site.register(Message)
        
    #管理ツールでMessageを使用
        サーバーを立ち上げ、http://localhost:8000/admin　から使用可能。
        
    #Messageページを作成  →   アプリ名/urls.pyに追記
        path('message/', views.message, name='message'),
        path('message/<int:page>', views.message, name='message')
        
        
    
       
        
 
 
 
